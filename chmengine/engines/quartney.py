"""Cmhmey Jr's Mom, Quartney"""
from abc import ABCMeta, abstractmethod
from os import makedirs, path
from sqlite3 import Connection, Cursor, connect
from typing import Optional, Tuple, Union

from chess import Board, Move
from numpy import float64

from chmengine.utils import pieces_count_from_fen
from chmutils import CACHE_DIR


class Quartney(metaclass=ABCMeta):
    """Mother class of Cmhmey Jr."""
    _depth: int
    board: Optional[Board]
    cache_dir: str = path.join(".", CACHE_DIR, "QTables")

    def qtable_filename(
            self,
            fen: Optional[str] = None,
            board: Optional[Board] = None,
            pieces_count: Optional[Union[int, str]] = None
    ) -> str:
        """Generate the filename for the Q-table database.

        The filename is constructed based on the current recursion depth and the number of pieces
        present on the board. If no piece count is provided, it is determined from the FEN string.

        Parameters
        ----------
        fen : Union[Optional[str], ]
            A FEN string to use for calculating the piece count. If None, the engine's current board
            FEN is used.
        board : Union[Optional[Board], ]
            A board object from which to determine the piece count if fen is not provided.
        pieces_count : Union[Optional[Union[int, str]], ]
            The number of pieces on the board. If not provided, it is calculated from the FEN.

        Returns
        -------
        str
            A filename string in the format: "qtable_depth_{depth}_piece_count_{piece_count}.db"

        Examples
        --------
        >>> import os
        >>> from chmengine.engines.cmhmey2 import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> engine.qtable_filename() in os.listdir(path=engine.cache_dir)
        True
        """
        return (
            f"qtable_depth_{self.depth}_"
            f"piece_count_{self.pieces_count(board=board, fen=fen) if pieces_count is None else pieces_count}.db"
        )

    def pieces_count(self, board: Optional[Board] = None, fen: Optional[str] = None) -> int:
        """Get pieces count from board state.

        Parameters
        ----------
        board : Optional[chess.Board]
        fen : Optional[str]

        Returns
        -------
        int

        Examples
        --------
        >>> from chmengine.engines.cmhmey2 import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> engine.pieces_count()
        32
        """
        return pieces_count_from_fen(
            fen=self.fen(board=board)
        ) if fen is None else pieces_count_from_fen(fen=fen)

    def qdb_path(
            self,
            fen: Optional[str] = None,
            board: Optional[Board] = None,
            pieces_count: Optional[Union[int, str]] = None,
    ) -> str:
        """Generate the full file path to the Q-table database.

        This method joins the cache directory with the Q-table filename generated by `qtable_filename()`,
        resulting in the full relative path where the database is stored.

        Parameters
        ----------
        fen : Union[Optional[str],]
            A FEN string to use for filename generation.
        board : Union[Optional[Board],]
            A board object to use for filename generation if fen is not provided.
        pieces_count : Union[Optional[Union[int, str]],]
            The piece count to use for filename generation.

        Returns
        -------
        str
            The full file path to the Q-table database.

        Examples
        --------
        >>> import os
        >>> from chmengine.engines.cmhmey2 import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> engine.qdb_path() == os.path.join(engine.cache_dir, engine.qtable_filename())
        True
        """
        return path.join(self.cache_dir, self.qtable_filename(fen=fen, board=board, pieces_count=pieces_count))

    def _init_qdb(self) -> None:
        """Initialize the Q-table database.

        This method ensures that the cache directory exists and creates the Q-table database
        for various piece count values (from 2 to 32 pieces). For each piece count, it creates
        a table (if not already present) with columns corresponding to move intensities for each
        square.

        Side Effects
        ------------
        Creates the directory "SQLite3Caches" if it does not exist and sets up the required
        tables and indexes in each Q-table database.
        """
        if not path.isdir(self.cache_dir):
            makedirs(self.cache_dir)
        pieces_count: int
        for pieces_count in range(2, 33):  # We are using dbs for 2-32 pieces
            qdb_path: str = self.qdb_path(pieces_count=pieces_count)
            q_conn: Connection
            with connect(qdb_path) as q_conn:
                q_cursor: Cursor = q_conn.cursor()
                q_cursor.execute(
                    """
                    CREATE TABLE IF NOT EXISTS q_table (
                        fen TEXT,
                        q_value REAL,
                        PRIMARY KEY (fen)
                    )
                    """
                )

    def get_q_value(
            self,
            fen: Optional[str] = None,
            board: Optional[Board] = None,
            pieces_count: Optional[int] = None
    ) -> Optional[float64]:
        """Retrieve the Q-value for a given board state from the Q-table database.

        If the state is not found in the database, returns None.

        Parameters
        ----------
        fen : str
            The FEN string of the board state. If None, the engine's current board FEN is used.
        board : Board
            The board corresponding to the FEN. Used for determining the file path if needed.
        pieces_count : Optional[int]
            The piece count to use for determining the database file.

        Returns
        -------
        Union[numpy.float64, None]
            The Q-value associated with the board state, or None if the state is not cached.

        Examples
        --------
        >>> from chmengine import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> q = engine.get_q_value()
        """
        fen = self.fen(board=board) if fen is None else fen
        q_conn: Connection
        with connect(self.qdb_path(fen=fen, board=board, pieces_count=pieces_count)) as q_conn:
            q_cursor: Cursor = q_conn.cursor()
            q_cursor.execute(
                "SELECT q_value FROM q_table WHERE fen = ?",
                (fen,)
            )
            row: Optional[Tuple[float]] = q_cursor.fetchone()
            return float64(row[0]) if row is not None else None

    def set_q_value(
            self,
            value: float,
            fen: Optional[str] = None,
            board: Optional[Board] = None,
            pieces_count: Optional[int] = None
    ) -> None:
        """Set or update the Q-value for a given board state in the Q-table database.

        Parameters
        ----------
        value : float
            The Q-value to store for the state.
        fen : Optional[str]
            The FEN string of the board state. If None, the engine's current board FEN is used.
        board : Optional[Board]
            The board used for determining the file path if fen is None.
        pieces_count : Optional[int]
            The piece count to use for determining the database file.

        Examples
        --------
        >>> from chmengine import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> engine.set_q_value(0.0, '1k6/8/8/8/8/3K4/8/8 w - - 0 1')
        """
        if fen is None:
            fen = self.fen(board=board)
        with connect(self.qdb_path(fen=fen, board=board, pieces_count=pieces_count)) as q_conn:
            q_cursor = q_conn.cursor()
            q_cursor.execute(
                "INSERT OR REPLACE INTO q_table (fen, q_value) VALUES (?, ?)",
                (fen, value)
            )

    @abstractmethod
    def fen(self, board: Board) -> str:
        """

        Parameters
        ----------
        board : chess.Board

        Returns
        -------
        str
        """

    @abstractmethod
    def update_q_values(self, debug: bool = False) -> None:
        """Update the Q-table values after game termination.

        This method back-propagates the outcome of the game by iteratively popping moves off the
        board stack and adjusting their Q-values based on the game outcome. For draws, scores are
        converged toward zero; for wins/losses, scores are bumped or penalized accordingly.

        Parameters
        ----------
        debug : bool

        Side Effects
        ------------
        Updates the Q-values in the Q-table database for each board fen in the move history.

        Examples
        --------
        >>> from io import StringIO
        >>> from chess import pgn
        >>> from chmengine import CMHMEngine2
        >>> pgn_buffer = StringIO(
        ...    '''
        ...    1. f3 e5 2. g4 Qh4# 0-1
        ...
        ...
        ...    '''
        ... )
        >>> game = pgn.read_game(pgn_buffer)
        >>> board = game.board()
        >>> for move in game.mainline_moves():
        ...     board.push(move)
        >>> engine = CMHMEngine2(board=board)
        >>> engine.fen()
        'rnb1kbnr/pppp1ppp/8/4p3/6Pq/5P2/PPPPP2P/RNBQKBNR w KQkq - 1 3'
        >>> engine.update_q_values()
        >>> engine.fen()
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        """

    @abstractmethod
    def pick_move(
            self,
            pick_by: str = "",
            board: Optional[Board] = None,
            debug: bool = False
    ) -> Tuple[Move, float64]:
        """Select a move based on heatmap evaluations and Q-table integration.

        This overridden method combines heatmap evaluations with Q-value updates. It evaluates all
        legal moves by calculating their scores from the perspective of the current player (with positive
        scores indicating favorable moves and negative scores indicating unfavorable moves). The evaluation
        score is always from the mover’s perspective. The method then picks one move at random from the
        top-scoring moves, updates the Q-value for that move, and returns the selected move along with its
        score.

        Parameters
        ----------
        pick_by : str, default: ""
            Legecy param from parent class pick_move method. Args are ignored by this classe's overide.
        board : Optional[chess.Board], default: None
            Pick from a given board instead of intstance board
        debug : bool, default: False
            Allows for a print call showing the current evals of each move choice during anaylsis.

        Returns
        -------
        Tuple[chess.Move, numpy.float64]
            A tuple containing the chosen move and its associated evaluation score. The evaluation score is
            expressed from the perspective of the player making the move—positive values indicate favorable
            outcomes and negative values indicate unfavorable outcomes.

        Raises
        ------
        ValueError
            If Current Board has no legal moves.

        Examples
        --------
        >>> from chmengine.engines.cmhmey2 import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> move, score = engine.pick_move()
        """

    @property
    def depth(self) -> int:
        """Get the current recursion depth setting.

        Returns
        -------
        int
            The current recursion depth used for heatmap calculations.

        Examples
        --------
        >>> from chmengine import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> engine.depth
        1
        """
        return self._depth

    @depth.setter
    def depth(self, new_depth: int):
        """Set the current recursion depth setting.

        Parameters
        ----------
        new_depth : int
            The new recursion depth. Must be greater than or equal to 0.

        Raises
        ------
        ValueError
            If new_depth is less than 0.

        Examples
        --------
        >>> from chmengine import CMHMEngine2
        >>> engine = CMHMEngine2()
        >>> engine.depth = 3
        >>> engine.depth
        3
        """
        if new_depth < 0:
            raise ValueError(f"Invalid depth, value must be greater than or equal to 0, got {new_depth}")
        self._depth = int(new_depth)
        self._init_qdb()
